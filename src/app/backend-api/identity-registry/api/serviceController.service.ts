/**
 * Maritime Connectivity Platform Identity Registry API
 * The MCP Identity Registry API can be used for managing entities in the Maritime Connectivity Platform.
 *
 * OpenAPI spec version: 0.12.2
 * Contact: info@maritimeconnectivity.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CertificateBundle } from '../model/certificateBundle';
import { CertificateRevocation } from '../model/certificateRevocation';
import { PageOfService } from '../model/pageOfService';
import { Service } from '../model/service';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ServiceControllerService {

    protected basePath = 'https://api.maritimeconnectivity.net';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * createService
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createServiceUsingPOST(input: Service, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Service>;
    public createServiceUsingPOST(input: Service, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Service>>;
    public createServiceUsingPOST(input: Service, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Service>>;
    public createServiceUsingPOST(input: Service, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling createServiceUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling createServiceUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Service>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * createService
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createServiceUsingPOST1(input: Service, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Service>;
    public createServiceUsingPOST1(input: Service, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Service>>;
    public createServiceUsingPOST1(input: Service, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Service>>;
    public createServiceUsingPOST1(input: Service, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling createServiceUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling createServiceUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Service>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteService
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteServiceUsingDELETE(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteServiceUsingDELETE(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteServiceUsingDELETE(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteServiceUsingDELETE(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteServiceUsingDELETE.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling deleteServiceUsingDELETE.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteServiceUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteService
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteServiceUsingDELETE1(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteServiceUsingDELETE1(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteServiceUsingDELETE1(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteServiceUsingDELETE1(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteServiceUsingDELETE1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling deleteServiceUsingDELETE1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteServiceUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationServices
     * 
     * @param orgMrn orgMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationServicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfService>;
    public getOrganizationServicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfService>>;
    public getOrganizationServicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfService>>;
    public getOrganizationServicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationServicesUsingGET.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfService>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/services`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationServices
     * 
     * @param orgMrn orgMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationServicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfService>;
    public getOrganizationServicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfService>>;
    public getOrganizationServicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfService>>;
    public getOrganizationServicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationServicesUsingGET1.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfService>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/services`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceJbossXml
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceJbossXmlUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getServiceJbossXmlUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getServiceJbossXmlUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getServiceJbossXmlUsingGET(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceJbossXmlUsingGET.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceJbossXmlUsingGET.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getServiceJbossXmlUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/jbossxml`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceJbossXml
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceJbossXmlUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getServiceJbossXmlUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getServiceJbossXmlUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getServiceJbossXmlUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceJbossXmlUsingGET1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceJbossXmlUsingGET1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getServiceJbossXmlUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/jbossxml`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceKeycloakJson
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceKeycloakJsonUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getServiceKeycloakJsonUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getServiceKeycloakJsonUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getServiceKeycloakJsonUsingGET(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceKeycloakJsonUsingGET.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceKeycloakJsonUsingGET.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getServiceKeycloakJsonUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/keycloakjson`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceKeycloakJson
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceKeycloakJsonUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public getServiceKeycloakJsonUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public getServiceKeycloakJsonUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public getServiceKeycloakJsonUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceKeycloakJsonUsingGET1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceKeycloakJsonUsingGET1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getServiceKeycloakJsonUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<string>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/keycloakjson`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getService
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceUsingGET(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfService>;
    public getServiceUsingGET(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfService>>;
    public getServiceUsingGET(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfService>>;
    public getServiceUsingGET(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceUsingGET.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceUsingGET.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfService>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getService
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceUsingGET1(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfService>;
    public getServiceUsingGET1(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfService>>;
    public getServiceUsingGET1(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfService>>;
    public getServiceUsingGET1(orgMrn: string, serviceMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceUsingGET1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceUsingGET1.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfService>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceVersion
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceVersionUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<Service>;
    public getServiceVersionUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Service>>;
    public getServiceVersionUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Service>>;
    public getServiceVersionUsingGET(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceVersionUsingGET.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceVersionUsingGET.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getServiceVersionUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Service>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getServiceVersion
     * 
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServiceVersionUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<Service>;
    public getServiceVersionUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Service>>;
    public getServiceVersionUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Service>>;
    public getServiceVersionUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getServiceVersionUsingGET1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling getServiceVersionUsingGET1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getServiceVersionUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Service>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newServiceCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newServiceCertFromCsrUsingPOST(csr: string, orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newServiceCertFromCsrUsingPOST(csr: string, orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newServiceCertFromCsrUsingPOST(csr: string, orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newServiceCertFromCsrUsingPOST(csr: string, orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newServiceCertFromCsrUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newServiceCertFromCsrUsingPOST.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling newServiceCertFromCsrUsingPOST.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling newServiceCertFromCsrUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newServiceCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newServiceCertFromCsrUsingPOST1(csr: string, orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newServiceCertFromCsrUsingPOST1(csr: string, orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newServiceCertFromCsrUsingPOST1(csr: string, orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newServiceCertFromCsrUsingPOST1(csr: string, orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newServiceCertFromCsrUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newServiceCertFromCsrUsingPOST1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling newServiceCertFromCsrUsingPOST1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling newServiceCertFromCsrUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newServiceCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newServiceCertUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newServiceCertUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newServiceCertUsingGET(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newServiceCertUsingGET(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newServiceCertUsingGET.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling newServiceCertUsingGET.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling newServiceCertUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newServiceCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newServiceCertUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newServiceCertUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newServiceCertUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newServiceCertUsingGET1(orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newServiceCertUsingGET1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling newServiceCertUsingGET1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling newServiceCertUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeServiceCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param input input
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeServiceCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeServiceCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeServiceCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeServiceCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeServiceCertUsingPOST.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeServiceCertUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeServiceCertUsingPOST.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling revokeServiceCertUsingPOST.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling revokeServiceCertUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeServiceCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param input input
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeServiceCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeServiceCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeServiceCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeServiceCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeServiceCertUsingPOST1.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeServiceCertUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeServiceCertUsingPOST1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling revokeServiceCertUsingPOST1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling revokeServiceCertUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateService
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateServiceUsingPUT(input: Service, orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateServiceUsingPUT(input: Service, orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateServiceUsingPUT(input: Service, orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateServiceUsingPUT(input: Service, orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateServiceUsingPUT.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateServiceUsingPUT.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling updateServiceUsingPUT.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateServiceUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateService
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param serviceMrn serviceMrn
     * @param version version
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateServiceUsingPUT1(input: Service, orgMrn: string, serviceMrn: string, version: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateServiceUsingPUT1(input: Service, orgMrn: string, serviceMrn: string, version: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateServiceUsingPUT1(input: Service, orgMrn: string, serviceMrn: string, version: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateServiceUsingPUT1(input: Service, orgMrn: string, serviceMrn: string, version: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateServiceUsingPUT1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateServiceUsingPUT1.');
        }

        if (serviceMrn === null || serviceMrn === undefined) {
            throw new Error('Required parameter serviceMrn was null or undefined when calling updateServiceUsingPUT1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateServiceUsingPUT1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/service/${encodeURIComponent(String(serviceMrn))}/${encodeURIComponent(String(version))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
