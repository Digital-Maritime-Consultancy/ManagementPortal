/**
 * Maritime Connectivity Platform Identity Registry API
 * The MCP Identity Registry API can be used for managing entities in the Maritime Connectivity Platform.
 *
 * OpenAPI spec version: 0.12.2
 * Contact: info@maritimeconnectivity.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CertificateBundle } from '../model/certificateBundle';
import { CertificateRevocation } from '../model/certificateRevocation';
import { Organization } from '../model/organization';
import { PageOfOrganization } from '../model/pageOfOrganization';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class OrganizationControllerService {

    protected basePath = 'https://api.maritimeconnectivity.net';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * applyOrganization
     * 
     * @param input input
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public applyOrganizationUsingPOST(input: Organization, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public applyOrganizationUsingPOST(input: Organization, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public applyOrganizationUsingPOST(input: Organization, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public applyOrganizationUsingPOST(input: Organization, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling applyOrganizationUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Organization>(`${this.basePath}/oidc/api/org/apply`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * applyOrganization
     * 
     * @param input input
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public applyOrganizationUsingPOST1(input: Organization, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public applyOrganizationUsingPOST1(input: Organization, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public applyOrganizationUsingPOST1(input: Organization, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public applyOrganizationUsingPOST1(input: Organization, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling applyOrganizationUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Organization>(`${this.basePath}/x509/api/org/apply`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * approveOrganization
     * 
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public approveOrganizationUsingGET(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public approveOrganizationUsingGET(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public approveOrganizationUsingGET(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public approveOrganizationUsingGET(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling approveOrganizationUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Organization>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/approve`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * approveOrganization
     * 
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public approveOrganizationUsingGET1(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public approveOrganizationUsingGET1(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public approveOrganizationUsingGET1(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public approveOrganizationUsingGET1(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling approveOrganizationUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Organization>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/approve`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteOrg
     * 
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteOrgUsingDELETE(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteOrgUsingDELETE(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteOrgUsingDELETE(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteOrgUsingDELETE(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteOrgUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteOrg
     * 
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteOrgUsingDELETE1(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteOrgUsingDELETE1(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteOrgUsingDELETE1(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteOrgUsingDELETE1(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteOrgUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationById
     * 
     * @param orgId orgId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationByIdUsingGET(orgId: number, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public getOrganizationByIdUsingGET(orgId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public getOrganizationByIdUsingGET(orgId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public getOrganizationByIdUsingGET(orgId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling getOrganizationByIdUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Organization>(`${this.basePath}/oidc/api/org/id/${encodeURIComponent(String(orgId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationById
     * 
     * @param orgId orgId
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationByIdUsingGET1(orgId: number, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public getOrganizationByIdUsingGET1(orgId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public getOrganizationByIdUsingGET1(orgId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public getOrganizationByIdUsingGET1(orgId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgId === null || orgId === undefined) {
            throw new Error('Required parameter orgId was null or undefined when calling getOrganizationByIdUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Organization>(`${this.basePath}/x509/api/org/id/${encodeURIComponent(String(orgId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganization
     * 
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfOrganization>;
    public getOrganizationUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfOrganization>>;
    public getOrganizationUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfOrganization>>;
    public getOrganizationUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfOrganization>(`${this.basePath}/oidc/api/orgs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganization
     * 
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfOrganization>;
    public getOrganizationUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfOrganization>>;
    public getOrganizationUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfOrganization>>;
    public getOrganizationUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfOrganization>(`${this.basePath}/x509/api/orgs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganization
     * 
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationUsingGET2(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public getOrganizationUsingGET2(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public getOrganizationUsingGET2(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public getOrganizationUsingGET2(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationUsingGET2.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Organization>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganization
     * 
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationUsingGET3(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Organization>;
    public getOrganizationUsingGET3(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Organization>>;
    public getOrganizationUsingGET3(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Organization>>;
    public getOrganizationUsingGET3(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationUsingGET3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Organization>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getUnapprovedOrganizations
     * 
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUnapprovedOrganizationsUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfOrganization>;
    public getUnapprovedOrganizationsUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfOrganization>>;
    public getUnapprovedOrganizationsUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfOrganization>>;
    public getUnapprovedOrganizationsUsingGET(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfOrganization>(`${this.basePath}/oidc/api/org/unapprovedorgs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getUnapprovedOrganizations
     * 
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getUnapprovedOrganizationsUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfOrganization>;
    public getUnapprovedOrganizationsUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfOrganization>>;
    public getUnapprovedOrganizationsUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfOrganization>>;
    public getUnapprovedOrganizationsUsingGET1(offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfOrganization>(`${this.basePath}/x509/api/org/unapprovedorgs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newOrgCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newOrgCertFromCsrUsingPOST(csr: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newOrgCertFromCsrUsingPOST(csr: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newOrgCertFromCsrUsingPOST(csr: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newOrgCertFromCsrUsingPOST(csr: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newOrgCertFromCsrUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newOrgCertFromCsrUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newOrgCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newOrgCertFromCsrUsingPOST1(csr: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newOrgCertFromCsrUsingPOST1(csr: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newOrgCertFromCsrUsingPOST1(csr: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newOrgCertFromCsrUsingPOST1(csr: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newOrgCertFromCsrUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newOrgCertFromCsrUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newOrgCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newOrgCertUsingGET(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newOrgCertUsingGET(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newOrgCertUsingGET(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newOrgCertUsingGET(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newOrgCertUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newOrgCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newOrgCertUsingGET1(orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newOrgCertUsingGET1(orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newOrgCertUsingGET1(orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newOrgCertUsingGET1(orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newOrgCertUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeOrgCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeOrgCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeOrgCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeOrgCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeOrgCertUsingPOST(certId: string, input: CertificateRevocation, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeOrgCertUsingPOST.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeOrgCertUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeOrgCertUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeOrgCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeOrgCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeOrgCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeOrgCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeOrgCertUsingPOST1(certId: string, input: CertificateRevocation, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeOrgCertUsingPOST1.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeOrgCertUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeOrgCertUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateOrganization
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateOrganizationUsingPUT(input: Organization, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateOrganizationUsingPUT(input: Organization, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateOrganizationUsingPUT(input: Organization, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateOrganizationUsingPUT(input: Organization, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateOrganizationUsingPUT.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateOrganizationUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateOrganization
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateOrganizationUsingPUT1(input: Organization, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateOrganizationUsingPUT1(input: Organization, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateOrganizationUsingPUT1(input: Organization, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateOrganizationUsingPUT1(input: Organization, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateOrganizationUsingPUT1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateOrganizationUsingPUT1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
