/**
 * Maritime Connectivity Platform Identity Registry API
 * The MCP Identity Registry API can be used for managing entities in the Maritime Connectivity Platform.
 *
 * OpenAPI spec version: 0.12.2
 * Contact: info@maritimeconnectivity.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CertificateBundle } from '../model/certificateBundle';
import { CertificateRevocation } from '../model/certificateRevocation';
import { MMS } from '../model/mMS';
import { PageOfMMS } from '../model/pageOfMMS';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class MmsControllerService {

    protected basePath = 'https://api.maritimeconnectivity.net';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * createMMS
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMMSUsingPOST(input: MMS, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<MMS>;
    public createMMSUsingPOST(input: MMS, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MMS>>;
    public createMMSUsingPOST(input: MMS, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MMS>>;
    public createMMSUsingPOST(input: MMS, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling createMMSUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling createMMSUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<MMS>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * createMMS
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMMSUsingPOST1(input: MMS, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<MMS>;
    public createMMSUsingPOST1(input: MMS, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MMS>>;
    public createMMSUsingPOST1(input: MMS, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MMS>>;
    public createMMSUsingPOST1(input: MMS, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling createMMSUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling createMMSUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<MMS>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteMMS
     * 
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMMSUsingDELETE(mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteMMSUsingDELETE(mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteMMSUsingDELETE(mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteMMSUsingDELETE(mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling deleteMMSUsingDELETE.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteMMSUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteMMS
     * 
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMMSUsingDELETE1(mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteMMSUsingDELETE1(mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteMMSUsingDELETE1(mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteMMSUsingDELETE1(mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling deleteMMSUsingDELETE1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteMMSUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getMMS
     * 
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMMSUsingGET(mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<MMS>;
    public getMMSUsingGET(mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MMS>>;
    public getMMSUsingGET(mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MMS>>;
    public getMMSUsingGET(mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling getMMSUsingGET.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getMMSUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<MMS>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getMMS
     * 
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMMSUsingGET1(mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<MMS>;
    public getMMSUsingGET1(mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MMS>>;
    public getMMSUsingGET1(mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MMS>>;
    public getMMSUsingGET1(mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling getMMSUsingGET1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getMMSUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<MMS>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationMMSes
     * 
     * @param orgMrn orgMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationMMSesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfMMS>;
    public getOrganizationMMSesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfMMS>>;
    public getOrganizationMMSesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfMMS>>;
    public getOrganizationMMSesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationMMSesUsingGET.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfMMS>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mmses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationMMSes
     * 
     * @param orgMrn orgMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationMMSesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfMMS>;
    public getOrganizationMMSesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfMMS>>;
    public getOrganizationMMSesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfMMS>>;
    public getOrganizationMMSesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationMMSesUsingGET1.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfMMS>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mmses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newMMSCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newMMSCertFromCsrUsingPOST(csr: string, mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newMMSCertFromCsrUsingPOST(csr: string, mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newMMSCertFromCsrUsingPOST(csr: string, mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newMMSCertFromCsrUsingPOST(csr: string, mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newMMSCertFromCsrUsingPOST.');
        }

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling newMMSCertFromCsrUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newMMSCertFromCsrUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newMMSCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newMMSCertFromCsrUsingPOST1(csr: string, mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newMMSCertFromCsrUsingPOST1(csr: string, mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newMMSCertFromCsrUsingPOST1(csr: string, mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newMMSCertFromCsrUsingPOST1(csr: string, mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newMMSCertFromCsrUsingPOST1.');
        }

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling newMMSCertFromCsrUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newMMSCertFromCsrUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newMMSCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newMMSCertUsingGET(mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newMMSCertUsingGET(mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newMMSCertUsingGET(mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newMMSCertUsingGET(mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling newMMSCertUsingGET.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newMMSCertUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newMMSCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newMMSCertUsingGET1(mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newMMSCertUsingGET1(mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newMMSCertUsingGET1(mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newMMSCertUsingGET1(mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling newMMSCertUsingGET1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newMMSCertUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeMMSCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param input input
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeMMSCertUsingPOST(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeMMSCertUsingPOST(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeMMSCertUsingPOST(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeMMSCertUsingPOST(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeMMSCertUsingPOST.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeMMSCertUsingPOST.');
        }

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling revokeMMSCertUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeMMSCertUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeMMSCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param input input
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeMMSCertUsingPOST1(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeMMSCertUsingPOST1(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeMMSCertUsingPOST1(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeMMSCertUsingPOST1(certId: string, input: CertificateRevocation, mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeMMSCertUsingPOST1.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeMMSCertUsingPOST1.');
        }

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling revokeMMSCertUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeMMSCertUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateMMS
     * 
     * @param input input
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateMMSUsingPUT(input: MMS, mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateMMSUsingPUT(input: MMS, mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateMMSUsingPUT(input: MMS, mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateMMSUsingPUT(input: MMS, mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateMMSUsingPUT.');
        }

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling updateMMSUsingPUT.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateMMSUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateMMS
     * 
     * @param input input
     * @param mmsMrn mmsMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateMMSUsingPUT1(input: MMS, mmsMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateMMSUsingPUT1(input: MMS, mmsMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateMMSUsingPUT1(input: MMS, mmsMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateMMSUsingPUT1(input: MMS, mmsMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateMMSUsingPUT1.');
        }

        if (mmsMrn === null || mmsMrn === undefined) {
            throw new Error('Required parameter mmsMrn was null or undefined when calling updateMMSUsingPUT1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateMMSUsingPUT1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/mms/${encodeURIComponent(String(mmsMrn))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
