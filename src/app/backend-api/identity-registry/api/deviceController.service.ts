/**
 * Maritime Connectivity Platform Identity Registry API
 * The MCP Identity Registry API can be used for managing entities in the Maritime Connectivity Platform.
 *
 * OpenAPI spec version: 0.12.2
 * Contact: info@maritimeconnectivity.net
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CertificateBundle } from '../model/certificateBundle';
import { CertificateRevocation } from '../model/certificateRevocation';
import { Device } from '../model/device';
import { PageOfDevice } from '../model/pageOfDevice';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DeviceControllerService {

    protected basePath = 'https://api.maritimeconnectivity.net';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * createDevice
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDeviceUsingPOST(input: Device, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Device>;
    public createDeviceUsingPOST(input: Device, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Device>>;
    public createDeviceUsingPOST(input: Device, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Device>>;
    public createDeviceUsingPOST(input: Device, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling createDeviceUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling createDeviceUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Device>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * createDevice
     * 
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDeviceUsingPOST1(input: Device, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Device>;
    public createDeviceUsingPOST1(input: Device, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Device>>;
    public createDeviceUsingPOST1(input: Device, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Device>>;
    public createDeviceUsingPOST1(input: Device, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling createDeviceUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling createDeviceUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Device>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteDevice
     * 
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteDeviceUsingDELETE(deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteDeviceUsingDELETE(deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteDeviceUsingDELETE(deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteDeviceUsingDELETE(deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling deleteDeviceUsingDELETE.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteDeviceUsingDELETE.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * deleteDevice
     * 
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteDeviceUsingDELETE1(deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteDeviceUsingDELETE1(deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteDeviceUsingDELETE1(deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteDeviceUsingDELETE1(deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling deleteDeviceUsingDELETE1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling deleteDeviceUsingDELETE1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getDevice
     * 
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDeviceUsingGET(deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Device>;
    public getDeviceUsingGET(deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Device>>;
    public getDeviceUsingGET(deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Device>>;
    public getDeviceUsingGET(deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling getDeviceUsingGET.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getDeviceUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Device>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getDevice
     * 
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDeviceUsingGET1(deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<Device>;
    public getDeviceUsingGET1(deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Device>>;
    public getDeviceUsingGET1(deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Device>>;
    public getDeviceUsingGET1(deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling getDeviceUsingGET1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getDeviceUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Device>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationDevices
     * 
     * @param orgMrn orgMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationDevicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfDevice>;
    public getOrganizationDevicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfDevice>>;
    public getOrganizationDevicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfDevice>>;
    public getOrganizationDevicesUsingGET(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationDevicesUsingGET.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfDevice>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/devices`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * getOrganizationDevices
     * 
     * @param orgMrn orgMrn
     * @param offset 
     * @param page Results page you want to retrieve (0..N)
     * @param paged 
     * @param pageNumber 
     * @param pageSize 
     * @param size Number of records per page
     * @param sort Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param sortSorted 
     * @param sortUnsorted 
     * @param unpaged 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrganizationDevicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'body', reportProgress?: boolean): Observable<PageOfDevice>;
    public getOrganizationDevicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PageOfDevice>>;
    public getOrganizationDevicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PageOfDevice>>;
    public getOrganizationDevicesUsingGET1(orgMrn: string, offset?: number, page?: number, paged?: boolean, pageNumber?: number, pageSize?: number, size?: number, sort?: string, sortSorted?: boolean, sortUnsorted?: boolean, unpaged?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling getOrganizationDevicesUsingGET1.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (page !== undefined && page !== null) {
            queryParameters = queryParameters.set('page', <any>page);
        }
        if (paged !== undefined && paged !== null) {
            queryParameters = queryParameters.set('paged', <any>paged);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (size !== undefined && size !== null) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (sortSorted !== undefined && sortSorted !== null) {
            queryParameters = queryParameters.set('sort.sorted', <any>sortSorted);
        }
        if (sortUnsorted !== undefined && sortUnsorted !== null) {
            queryParameters = queryParameters.set('sort.unsorted', <any>sortUnsorted);
        }
        if (unpaged !== undefined && unpaged !== null) {
            queryParameters = queryParameters.set('unpaged', <any>unpaged);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PageOfDevice>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/devices`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newDeviceCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newDeviceCertFromCsrUsingPOST(csr: string, deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newDeviceCertFromCsrUsingPOST(csr: string, deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newDeviceCertFromCsrUsingPOST(csr: string, deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newDeviceCertFromCsrUsingPOST(csr: string, deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newDeviceCertFromCsrUsingPOST.');
        }

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling newDeviceCertFromCsrUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newDeviceCertFromCsrUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newDeviceCertFromCsr
     * 
     * @param csr A PEM encoded PKCS#10 CSR
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newDeviceCertFromCsrUsingPOST1(csr: string, deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<string>;
    public newDeviceCertFromCsrUsingPOST1(csr: string, deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;
    public newDeviceCertFromCsrUsingPOST1(csr: string, deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;
    public newDeviceCertFromCsrUsingPOST1(csr: string, deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (csr === null || csr === undefined) {
            throw new Error('Required parameter csr was null or undefined when calling newDeviceCertFromCsrUsingPOST1.');
        }

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling newDeviceCertFromCsrUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newDeviceCertFromCsrUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8',
            'application/pem-certificate-chain'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'text/plain'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<string>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}/certificate/issue-new/csr`,
            csr,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newDeviceCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newDeviceCertUsingGET(deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newDeviceCertUsingGET(deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newDeviceCertUsingGET(deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newDeviceCertUsingGET(deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling newDeviceCertUsingGET.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newDeviceCertUsingGET.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * newDeviceCert
     * DEPRECATED: Issues a bundle containing a certificate, the key pair of the certificate and keystores in JKS and PKCS#12 formats. As server generated key pairs are not considered secure this endpoint should not be used, and anybody who does should migrate to the endpoint for issuing certificates using certificate signing requests as soon as possible. This endpoint will be removed completely in the future and providers may choose to already disable it now which will result in an error if called.
     * @param deviceMrn deviceMrn
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newDeviceCertUsingGET1(deviceMrn: string, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<CertificateBundle>;
    public newDeviceCertUsingGET1(deviceMrn: string, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CertificateBundle>>;
    public newDeviceCertUsingGET1(deviceMrn: string, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CertificateBundle>>;
    public newDeviceCertUsingGET1(deviceMrn: string, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling newDeviceCertUsingGET1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling newDeviceCertUsingGET1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CertificateBundle>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}/certificate/issue-new`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeDeviceCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param deviceMrn deviceMrn
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeDeviceCertUsingPOST(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeDeviceCertUsingPOST(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeDeviceCertUsingPOST(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeDeviceCertUsingPOST(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeDeviceCertUsingPOST.');
        }

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling revokeDeviceCertUsingPOST.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeDeviceCertUsingPOST.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeDeviceCertUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * revokeDeviceCert
     * 
     * @param certId The serial number of the certificate given in decimal
     * @param deviceMrn deviceMrn
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeDeviceCertUsingPOST1(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public revokeDeviceCertUsingPOST1(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public revokeDeviceCertUsingPOST1(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public revokeDeviceCertUsingPOST1(certId: string, deviceMrn: string, input: CertificateRevocation, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (certId === null || certId === undefined) {
            throw new Error('Required parameter certId was null or undefined when calling revokeDeviceCertUsingPOST1.');
        }

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling revokeDeviceCertUsingPOST1.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling revokeDeviceCertUsingPOST1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling revokeDeviceCertUsingPOST1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json;charset=UTF-8'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}/certificate/${encodeURIComponent(String(certId))}/revoke`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateDevice
     * 
     * @param deviceMrn deviceMrn
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateDeviceUsingPUT(deviceMrn: string, input: Device, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateDeviceUsingPUT(deviceMrn: string, input: Device, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateDeviceUsingPUT(deviceMrn: string, input: Device, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateDeviceUsingPUT(deviceMrn: string, input: Device, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling updateDeviceUsingPUT.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateDeviceUsingPUT.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateDeviceUsingPUT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/oidc/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * updateDevice
     * 
     * @param deviceMrn deviceMrn
     * @param input input
     * @param orgMrn orgMrn
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateDeviceUsingPUT1(deviceMrn: string, input: Device, orgMrn: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateDeviceUsingPUT1(deviceMrn: string, input: Device, orgMrn: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateDeviceUsingPUT1(deviceMrn: string, input: Device, orgMrn: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateDeviceUsingPUT1(deviceMrn: string, input: Device, orgMrn: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (deviceMrn === null || deviceMrn === undefined) {
            throw new Error('Required parameter deviceMrn was null or undefined when calling updateDeviceUsingPUT1.');
        }

        if (input === null || input === undefined) {
            throw new Error('Required parameter input was null or undefined when calling updateDeviceUsingPUT1.');
        }

        if (orgMrn === null || orgMrn === undefined) {
            throw new Error('Required parameter orgMrn was null or undefined when calling updateDeviceUsingPUT1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/x509/api/org/${encodeURIComponent(String(orgMrn))}/device/${encodeURIComponent(String(deviceMrn))}`,
            input,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
